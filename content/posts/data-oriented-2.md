---
title: データ指向アプリケーションデザインメモ2
date: "2019-09-14T11:00:00.000Z"
template: "post"
draft: false
slug: "/posts/data-oriented-2/"
category: "daily"
tags:
  - "study"
description: "読書ログ"
---

## このページについて

データ指向アプリケーションデザイン読書の記録をつらつらと書いておく

## 6章 パーティション

**ローカルインデックス**
パーティショニングされた空間内でのセカンダリインデックス  
パーティショニングまたいだクエリが打たれると結果を結合しないといけないので負荷が高まりがち  
上記アプローチはスキャッタ/ギャザーと呼ばれる

**グローバルインデックス**
パーティション関係なしにインデックスを保持する  
ただし、この空間もパーティショニングは可能で、例えば色でいうと先頭 `a ~ s`, `t ~ z` のように分けられる  
しかし、書き込み時に複数のインデックスが指定されている場合は完了までに時間がかかりうる
(基本的にこれは非同期で行われるらしい。なので、書き込み直後はインデックス検索のデータが反映されてないかもしれない)

HBaseやMongoDBは動的にパーティションを生成するアルゴリズムが組み込まれている  
例えば、あるパーティションが10GBに達したら、5GB - 5GB のパーティションに分割される

@Todo
gossipプロトコル

## 7章 トランザクション

大まかな発想は40年変わっていない

- read committed
- スナップショット分離
- 直列化可能性

トランザクションが提供する安全性の保証は総じてACIDと呼ばれる。復習がてら追記してく。

**Atomic**
コミットさえしなければデータが変更されない。何か不慮のことが起きても途中の書き込み(状態?)をすべてリセットできる

**Consistency**
一貫性はアプリケーションでハンドリングするのでここでは深くふれない
ビジネス要件にもよって変わる。あくまでトランザクションを使ってどうこうなので。

**Isolation**
並行して発行されたトランザクションが、お互い副作用を起こさないこと。独立性を保証する。

**Persistant**
永続性は、トランザクションのコミットが行われたらデータが消失することがないと保証する
ただし、コミット後にハードがすっ飛んだり物理的な異常はしょうがなし。

**使う側からしたdbがエラーハンドリングに関するtips**

- 過負荷で応答ができないときはそのままリトライしても悪化させるだけなので指数的にリクエストのwaitを入れる
  - そもそも過負荷によるエラーなのかアプリケーションが把握できるとよい
- リトライすべきは一時的と判断できるエラーのみ。**恒久的なエラーについては行わないようにしたい**
- リトライ中にアプリが落ちたらデータは失われるのでファイルorメモリにデータはもつようにすべき

### 分離性レベル

**Read Committed**

- DBからの読み取りを行った際に見えるデータはコミットされたもののみであること
  - ダーティリードは生じない
- DBへ書き込みを行うとき、上書きするのはコミットされたデータのみであること
  - ダーティライトは生じない

- ただし連続したアップデート

**スナップショット分離**

常にコミット済みのものを新しく作り、バージョニングしていく
読み取りと書き込みがバッティングしないメリットがある

@Todo
Redisの優先順位つきキュー

同時に読み込まれるかつ、書き込みがある可能性のあるものはfor updateで  
他からブロックするべき。でないと読み込み->書き込みで意図しない状況になることがある
for update はcommit or rollback で解放される

|                   |                                                                              |
| ----------------- | ---------------------------------------------------------------------------- |
| FOR UPDATE        | 自分が更新する目的で行をロックしておく                                       |
| FOR SHARE         | 他からの更新がかからないように行をロックをしておく                           |
| FOR UPDATE NOWAIT | ロックが重なった場合は、後からロックを取ろうとしたトランザクションが即エラー |

衝突の実体化 -> ファントムリードが起きないよう、ロックをかけられるように必要な概念をテーブルに起こすこと
              難しさと、アプリケーションレベルで並行性の制御は間違えやすいので最後の手段

VoltDBはパーティショニングしたものにCPU割り当ててトランザクションができる
ただし、パーティションをまたぐトランザクションはコストが高い(1000回/秒)し、スケールできない模様

**2PL**
2フェーズロックは、書き込みをしようとするトランザクションがない限り、並行に読み込みを行える  
しかし、トランザクション(書き込み)がある場合はそのトランザクションが終了するまで読み書きができない
これは、一つのトランザクションの時間によって他の処理に影響を与えるので並行性のパフォーマンスはとれない

**直列化可能スナップショット分離**
seriarizable snapshot isolation(SSI)
楽観的ロックのアプローチをとる  
トランザクションはコミットの時点でチェックされ、その実行が直列化可能になっていなければ中断になる。  
要は、実行途中に他のトランザクションによって整合性がとれなくなったら。
まだ新しい(2008~)研究成果。foundationDBが採用している。よさそうだけど流行ってない?  
書き込み(更新含む)のトランザクションがバッティングした場合、後のトランザクション要求は失敗するようになっている  
読み書きのトランザクションを短く使えれば、安全にパフォーマンス良く使うことができる。  
読み込み同士はバッティングしてもDBが続行させてくれるので、読み込みが長期にわたるトランザクションでも大丈夫  

## 8章 分散システムの問題

分散システムを構築するのであれば、部分障害の可能性を必ず考慮する。  
システムのいくつかがおかしくなることは**必ずやってくる**

@Todo
AkkaやCassandraに搭載されている `Phi Accrual failure detector`
レスポンスタイムの変動(ジッター)を考慮したタイムアウトアルゴリズム?

@Todo
仮想マシンを使うメリット

マシンのクロック管理の仕組みも取り入れるべき

@Todo
Spannerの論文
クロックを利用したトランザクションID生成をどう解決しているか、また分散トランザクションについて

分散システムは、共有メモリがなく、完全に信頼できないネットワーク上でメッセージを送り合うので
限られた状況下でのシステムの振る舞いを定義していく必要がある。  
そのためには自分たちが構築するインフラがどんな特徴をもっていて、どんな障害が考えられるのか把握しておかないとならない
どこでメッセージが失われるか、その場合アプリケーションで担保するのか、その下のレイヤで担保できるのかなど

## 9章 一貫性と合意

